non_missing_aes = c("size", "shape", "colour", "y"),
default_aes = ggplot2::aes(y = 0.5, shape = 19, colour = "grey",
size = 5, fill = "grey20", alpha = 0.2,
stroke = 0.5),
draw_key = ggplot2::draw_key_point,
draw_panel = function(data, panel_params, coord) {
coords <- coord$transform(data, panel_params)
points <- grid::pointsGrob(
coords$x, coords$y,
pch = coords$shape,
gp = grid::gpar(
col = alpha(coords$colour, coords$alpha),
fill = alpha(coords$fill, coords$alpha),
lwd = coords$stroke * .pt,
fontsize = coords$size * .pt
)
)
lines <- purrr::map(unique(coords$y), function(x)
grid::linesGrob(y = c(x, x)))
params <- c(list(points), lines)
grid::gTree(children = rlang::exec(grid::gList, !!!params))
}
)
NOAA_data %>%
dplyr::filter(Country %in% c("IRAN", "MEXICO", "CHINA") &
Date %within% lubridate::interval(ymd(20000103), ymd(20180104))) %>%
dplyr::mutate(Country = factor(Country, levels = unique(Country))) %>%
ggplot2::ggplot() +
geom_timeline(aes(x = Date, y = Country, size = Mag, colour = Deaths)) +
ggplot2::scale_colour_continuous(name = "# deaths") +
ggplot2::scale_size_continuous(name = "Richter scale value") +
ggplot2::theme(legend.position = "bottom") +
ggplot2::ylab("")
args <- list(x = c(1:10, 100, NA), na.rm = TRUE)
args
exec("mean", !!!args)
exec("mean", args)
rm(args)
#' GeomTimelineLabel
#'
#' @description
#' This is the setup required for creating a new geom class. This GeomTimeLineLabel
#'  inherits from a top level class called Geom. It creates a geom that draws the
#'  timeline for a specified date interval and put points on it for each earthquake.
#'  It then creates labels in order to annotate the biggest earthquakes on the
#'  timeline.
#'
#' @export
GeomTimeLineLabel <- ggplot2::ggproto("GeomTimeLineLabel", ggplot2::Geom,
required_aes = c("x", "label", "magnitude"),
non_missing_aes = c("size", "shape", "colour", "y"),
default_aes = ggplot2::aes(y = 0.5, shape = 19, colour = "grey",
size = 3, fill = "grey20", alpha = 0.5,
stroke = 0, n_max = 5),
draw_key = ggplot2::draw_key_point,
draw_panel = function(data, panel_scales, coord) {
n_max <- data$n_max[1]
data <- data %>%
dplyr::group_by(group) %>%
dplyr::slice_max(magnitude, n = n_max)
coords <- coord$transform(data, panel_scales)
points <- grid::pointsGrob(
coords$x, coords$y,
pch = coords$shape,
gp = grid::gpar(
col = alpha(coords$colour, coords$alpha),
fill = alpha(coords$fill, coords$alpha),
lwd = coords$size * .pt,
fontsize = coords$size * .pt
)
)
labels <- grid::textGrob(
coords$label,
coords$x, coords$y + 0.15,
coords$just <- "centre",
coords$hjust <- "right",
coords$vjust <- "top",
rot = 45,
gp = grid::gpar(lwd = coords$size * .pt)
)
seg_label <- grid::segmentsGrob(
x0 = coords$x,
y0 = coords$y,
x1 = coords$x,
y1 = coords$y + 0.1
)
lines <- purrr::map(unique(coords$y), function(x)
grid::linesGrob(y = c(x, x)))
params <- c(list(points), lines, list(labels),
list(seg_label))
grid::gTree(children = rlang::exec(grid::gList,
!!!params))
}
)
#'                Date %within% lubridate::interval(ymd(20000103), ymd(20180104))) %>%
#' dplyr::mutate(Country = factor(Country, levels = unique(Country))) %>%
#' ggplot2::ggplot() +
#' geom_timeline(aes(x = Date, y = Country, size = Mag, colour = Deaths)) +
#' geom_timeline_label(aes(x = Date, y = Country, label = Location,
#'                          magnitude = Mag, colour = Deaths, n_max = 7), alpha = 0.5) +
#' ggplot2::scale_colour_continuous(name = "# deaths") +
#' ggplot2::theme(legend.position = "bottom") +
#' ggplot2::ylab("")
#' @export
geom_timeline_label <- function(mapping = NULL, data = NULL, stat = "identity",
position = "identity", show.legend = NA,
na.rm = FALSE, inherit.aes = TRUE, ...) {
ggplot2::layer(
data = data,
mapping = mapping,
stat = stat,
geom = GeomTimeLineLabel,
position = position,
show.legend = show.legend,
inherit.aes = inherit.aes,
params = list(na.rm = na.rm, ...)
)
}
NOAA_data
NOAA_data %>%
dplyr::filter(Country %in% c("MEXICO", "IRAN") &
Date %within% lubridate::interval(ymd(20000103), ymd(20180104))) %>%
dplyr::mutate(Country = factor(Country, levels = unique(Country))) %>%
ggplot2::ggplot() +
geom_timeline(aes(x = Date, y = Country, size = Mag, colour = Deaths)) +
geom_timeline_label(aes(x = Date, y = Country, label = Location,
magnitude = Mag, colour = Deaths, n_max = 7), alpha = 0.5) +
ggplot2::scale_colour_continuous(name = "# deaths") +
ggplot2::theme(legend.position = "bottom") +
ggplot2::ylab("")
#' GeomTimelineLabel
#'
#' @description
#' This is the setup required for creating a new geom class. This GeomTimeLineLabel
#'  inherits from a top level class called Geom. It creates a geom that draws the
#'  timeline for a specified date interval and put points on it for each earthquake.
#'  It then creates labels in order to annotate the biggest earthquakes on the
#'  timeline.
#'
#' @export
GeomTimeLineLabel <- ggplot2::ggproto("GeomTimeLineLabel", ggplot2::Geom,
required_aes = c("x", "label", "magnitude"),
non_missing_aes = c("size", "shape", "colour", "y"),
default_aes = ggplot2::aes(y = 0.5, shape = 19, colour = "grey",
size = 3, fill = "grey20", alpha = 0.5,
stroke = 0, n_max = 5),
draw_key = ggplot2::draw_key_point,
draw_panel = function(data, panel_scales, coord) {
n_max <- data$n_max[1]
data <- data %>%
dplyr::group_by(group) %>%
dplyr::slice_max(magnitude, n = n_max)
coords <- coord$transform(data, panel_scales)
points <- grid::pointsGrob(
coords$x, coords$y,
pch = coords$shape,
gp = grid::gpar(
col = alpha(coords$colour, coords$alpha),
fill = alpha(coords$fill, coords$alpha),
lwd = coords$size * .pt,
fontsize = coords$size * .pt
)
)
labels <- grid::textGrob(
coords$label,
coords$x, coords$y + 0.15,
coords$just <- "centre",
coords$hjust <- "right",
coords$vjust <- "top",
rot = 45,
gp = grid::gpar(lwd = coords$size * .pt)
)
seg_label <- grid::segmentsGrob(
x0 = coords$x,
y0 = coords$y,
x1 = coords$x,
y1 = coords$y + 0.1
)
lines <- lapply(unique(coords$y), function(x)
grid::linesGrob(y = c(x, x)))
grobList <- c(list(points), lines, list(labels),
list(seg_label))
grid::gTree(children = do.call(grid::gList, grobList))
}
)
NOAA_data %>%
dplyr::filter(Country %in% c("MEXICO", "IRAN") &
Date %within% lubridate::interval(ymd(20000103), ymd(20180104))) %>%
dplyr::mutate(Country = factor(Country, levels = unique(Country))) %>%
ggplot2::ggplot() +
geom_timeline(aes(x = Date, y = Country, size = Mag, colour = Deaths)) +
geom_timeline_label(aes(x = Date, y = Country, label = Location,
magnitude = Mag, colour = Deaths, n_max = 7), alpha = 0.5) +
ggplot2::scale_colour_continuous(name = "# deaths") +
ggplot2::theme(legend.position = "bottom") +
ggplot2::ylab("")
NOAA_data %>%
dplyr::filter(Country %in% c("MEXICO", "IRAN") &
Date %within% lubridate::interval(ymd(20000103), ymd(20180104))) %>%
dplyr::mutate(Country = factor(Country, levels = unique(Country))) %>%
ggplot2::ggplot() +
geom_timeline(aes(x = Date, y = Country, size = Mag, colour = Deaths)) +
geom_timeline_label(aes(x = Date, y = Country, label = Location,
magnitude = Mag, colour = Deaths, n_max = 7), alpha = 0.5) +
ggplot2::scale_colour_continuous(name = "# deaths") +
ggplot2::theme(legend.position = "bottom") +
ggplot2::ylab("")
#' GeomTimelineLabel
#'
#' @description
#' This is the setup required for creating a new geom class. This GeomTimeLineLabel
#'  inherits from a top level class called Geom. It creates a geom that draws the
#'  timeline for a specified date interval and put points on it for each earthquake.
#'  It then creates labels in order to annotate the biggest earthquakes on the
#'  timeline.
#'
#' @export
GeomTimeLineLabel <- ggplot2::ggproto("GeomTimeLineLabel", ggplot2::Geom,
required_aes = c("x", "label", "magnitude"),
non_missing_aes = c("size", "shape", "colour", "y"),
default_aes = ggplot2::aes(y = 0.5, shape = 19, colour = "grey",
size = 3, fill = "grey20", alpha = 0.5,
stroke = 0, n_max = 5),
draw_key = ggplot2::draw_key_point,
draw_panel = function(data, panel_scales, coord) {
n_max <- data$n_max[1]
data <- data %>%
dplyr::group_by(group) %>%
dplyr::slice_max(magnitude, n = n_max)
coords <- coord$transform(data, panel_scales)
points <- grid::pointsGrob(
coords$x, coords$y,
pch = coords$shape,
gp = grid::gpar(
col = alpha(coords$colour, coords$alpha),
fill = alpha(coords$fill, coords$alpha),
lwd = coords$size * .pt,
fontsize = coords$size * .pt
)
)
labels <- grid::textGrob(
coords$label,
coords$x, coords$y + 0.15,
coords$just <- "centre",
coords$hjust <- "right",
coords$vjust <- "top",
rot = 45,
gp = grid::gpar(lwd = coords$size * .pt)
)
seg_label <- grid::segmentsGrob(
x0 = coords$x,
y0 = coords$y,
x1 = coords$x,
y1 = coords$y + 0.1
)
lines <- purrr::map(unique(coords$y), function(x)
grid::linesGrob(y = c(x, x)))
params <- c(list(points), lines, list(labels),
list(seg_label))
grid::gTree(children = rlang::exec(grid::gList,
!!!params))
}
)
NOAA_data %>%
dplyr::filter(Country %in% c("MEXICO", "IRAN") &
Date %within% lubridate::interval(ymd(20000103), ymd(20180104))) %>%
dplyr::mutate(Country = factor(Country, levels = unique(Country))) %>%
ggplot2::ggplot() +
geom_timeline(aes(x = Date, y = Country, size = Mag, colour = Deaths)) +
geom_timeline_label(aes(x = Date, y = Country, label = Location,
magnitude = Mag, colour = Deaths, n_max = 7), alpha = 0.5) +
ggplot2::scale_colour_continuous(name = "# deaths") +
ggplot2::theme(legend.position = "bottom") +
ggplot2::ylab("")
usethis::use_package("purrr")
usethis::use_package("rlang")
usethis::use_testthat()
stringr::str_length("abc")
length("abc")
?stringr::str_length()
library(testthat)
?test_that()
data("NOAA_data")
#' @param data a data frame of NOAA earthquake.
#'
#' @return A \code{tibble} with a new column \code{Date} but removing
#' \code{Year}, \code{Mo} & \code{Dy} variables of the input data frame.
#'
#' @examples
#' data(NOAA_data)
#' eq <- eq_clean_data(NOAA_data)
#'
#' @export
eq_clean_data <- function(data) {
clean_data <- data %>%
dplyr::mutate(Year = stringr::str_pad(Year, 4, "left", pad = 0)) %>%
tidyr::unite(Date, Year, Mo, Dy, remove = TRUE) %>%
dplyr::mutate(Date = lubridate::ymd(Date),
dplyr::across(c("Longitude", "Latitude"), as.numeric))
clean_data
}
#' @return
#' a \code{tibble} with one additional column which is the result of the
#'  previous \code{Location Name} being divided into two columns \code{Country}
#'  and \code{Location}.
#'
#' @examples
#' data(NOAA_data)
#' eq2 <- eq_location_clean("NOAA_data")
#'
#' @export
eq_location_clean <- function(data) {
NOAA_clean <- data %>%
tidyr::separate(`Location Name`, c("Country", "Location"), ": ", remove = TRUE) %>%
dplyr::mutate(Location = stringr::str_to_title(Location),
Location = stringr::str_trim(Location, "left"))
NOAA_clean
}
NOAA_data <- NOAA_data %>% eq_clean_data() %>% eq_location_clean()
NOAA_data
class(NOAA_data$Date)
test_that("The class of the newly created Date column", {
expect_true(class(NOAA_data$Date == "Date"))
})
test_that("The class of the newly created Date column", {
expect_true(class(NOAA_data$Date == Date))
})
NOAA_data$Date == "Date"
NOAA_data$Date == Date
test_that("The class of the newly created Date column", {
expect_true(class(NOAA_data$Date) == "Date")
})
test_that("The class of the newly created Date column", {
expect_true(class(NOAA_data$Date) == "Date")
expect_true(class(NOAA_data$Longitude) == "Numeric")
expect_true(class(NOAA_data$Latitude) == "Numeric")
})
test_that("The class of the newly created Date column", {
expect_true(class(NOAA_data$Date) == "Date")
expect_true(class(NOAA_data$Longitude) == "double")
expect_true(class(NOAA_data$Latitude) == "double")
})
View(NOAA_data)
test_that("The class of the newly created Date column", {
expect_true(class(NOAA_data$Date) == "Date")
expect_true(class(NOAA_data$Longitude) == "numeric")
expect_true(class(NOAA_data$Latitude) == "numeric")
})
?lubridate::floor_date
library(noaar)
NOAA_data <- NOAA_data %>%
eq_clean_data() %>%
eq_location_clean()
library(magrittr)
NOAA_data <- NOAA_data %>%
eq_clean_data() %>%
eq_location_clean()
NOAA_data
test_that("The class of the newly created Date column", {
expect_true(class(NOAA_data$Date) == "Date")
expect_true(class(NOAA_data$Longitude) == "numeric")
expect_true(class(NOAA_data$Latitude) == "numeric")
})
library(testthat)
library(noaar)
library(magrittr)
test_that("The class of the newly created Date column", {
expect_true(class(NOAA_data$Date) == "Date")
expect_true(class(NOAA_data$Longitude) == "numeric")
expect_true(class(NOAA_data$Latitude) == "numeric")
})
test_check("noaar")
View(NOAA_data)
#' @return Returns a \code{leaflet} map.
#'
#' @examples
#' NOAA_data %>%
#'  eq_clean_data() %>%
#'  eq_location_clean() %>%
#'  dplyr::filter(Country == "MEXICO" & year(Date) >= 2000) %>%
#'  eq_map(annot_col = "Date")
#'
#' @export
eq_map <- function(data, annot_col) {
# note that annot_col in a character string
leaflet::leaflet() %>%
leaflet::addTiles() %>%
leaflet::addCircleMarkers(data = data, radius = ~ Mag,
lng = ~ Longitude, lat = ~ Latitude,
popup = ~ data[[annot_col]])
}
#'
#' @examples
#' NOAA_data %>%
#'  eq_clean_data() %>%
#'  eq_location_clean() %>%
#'  dplyr::filter(Country %in% c("HONDURAS", "MEXICO") & year(Date) >= 2000) %>%
#'  dplyr::mutate(popup_text = eq_create_label(.)) %>%
#'  eq_map(annot_col = "popup_text")
#'
#' @export
eq_create_label <- function(data) {
labelled_data <- data %>%
dplyr::mutate(popup_text = paste("<b>Location:</b>", Location, "<br />",
"<b>Magnitude:</b>", Mag, "<br />",
"<b>Total Deaths:</b>", Deaths, "<br />"),
popup_text = ifelse(is.na(Location) | is.na(Mag) | is.na(Deaths),
paste("<b>No Data Available</b>"), popup_text))
labelled_data$popup_text
}
NOAA_data %>%
dplyr::filter(Country == "MEXICO" & year(Date) >= 2000) %>%
eq_map(annot_col = "Date")
NOAA_data %>%
dplyr::filter(Country == "MEXICO" & lubridate::year(Date) >= 2000) %>%
eq_map(annot_col = "Date")
map <- NOAA_data %>%
dplyr::filter(Country == "MEXICO" & lubridate::year(Date) >= 2000) %>%
eq_map(annot_col = "Date")
class(map)
eq_map(annot_col = Date)
test_that("Throwing error if the annot_col value in not a character strings", {
expect_error(eq_map(NOAA_data, Date), "annot_col argument needs to be a
character string")
})
test_that("Throwing error if the annot_col value in not a character strings", {
expect_error(eq_map(NOAA_data, "Date"), "annot_col argument needs to be a
character string")
})
test_that("Throwing error if the annot_col value in not a character strings", {
expect_error(eq_map(NOAA_data, Date), "annot_col argument needs to be a
character string")
})
NOAA_data <- NOAA_data %>%
eq_clean_data() %>%
eq_location_clean()
test_that("The data preparation process has been successful", {
expect_true(class(NOAA_data$Date) == "Date")
expect_true(class(NOAA_data$Longitude) == "numeric")
expect_true(class(NOAA_data$Latitude) == "numeric")
})
test_that("Throwing error if the annot_col value in not a character strings", {
expect_error(eq_map(NOAA_data, Date), "annot_col argument needs to be a
character string")
})
test_that("Throwing error if the annot_col value in not a character strings", {
expect_error(eq_map(NOAA_data, NOAA_data$Date), "annot_col argument needs to be a
character string")
})
NOAA_data
test_that("Throwing error if the annot_col value in not a character strings", {
expect_error(eq_map(NOAA_data, annot_col = NOAA_data$Date), "annot_col argument needs to be a
character string")
})
test_that("Throwing error if the annot_col value in not a character strings", {
expect_error(eq_map(NOAA_data, annot_col = NOAA_data[["Date"]]),
"annot_col argument needs to be a character string")
})
test_that("Throwing error if the annot_col value in not a character strings", {
expect_error(eq_map(NOAA_data, annot_col = "Date"),
"annot_col argument needs to be a character string")
})
test_that("Throwing error if the annot_col value in not a character strings", {
expect_error(eq_map(NOAA_data, annot_col = Date),
"annot_col argument needs to be a character string")
})
library(noaar)
library(noaar)
library(noaar)
library(noaar)
devtools::check()
usethis::use_package("readr")
devtools::check()
usethis::use_readme_rmd()
devtools::build_readme()
devtools::build_readme()
devtools::check()
usethis::use_travis()
devtools::check()
devtools::check()
testthat::test_check("noaar")
rlang::last_error()
rlang::last_error()
testthat::test_check("noaar")
devtools::test()
devtools::test()
usethis::use_package("magrittr")
devtools::check()
devtools::check()
devtools::check()
library(noaar)
NOAA_data %>%
eq_clean_data() %>%
eq_location_clean() %>%
dplyr::filter(Country %in% c("HONDURAS", "MEXICO") & lubridate::year(Date) >= 2000) %>%
dplyr::mutate(popup_text = eq_create_label(.)) %>%
eq_map(annot_col = "popup_text")
requireNamespace("magrittr")
NOAA_data %>%
eq_clean_data() %>%
eq_location_clean() %>%
dplyr::filter(Country %in% c("HONDURAS", "MEXICO") & lubridate::year(Date) >= 2000) %>%
dplyr::mutate(popup_text = eq_create_label(.)) %>%
eq_map(annot_col = "popup_text")
usethis::use_package("magrittr", type = "depends")
usethis::use_package("magrittr")
usethis::use_package("magrittr", type = "imports")
usethis::use_package("magrittr", type = "imports")
usethis::use_package("magrittr", type = "imports")
devtools::check()
usethis::use_package("tibble", type = "imports")
devtools::check()
